<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>CardByte Event Handler</title>

  <!-- Office.js -->
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>

  <script>
    /* =========================================================
       CARDBYTE ‚Äì OUTLOOK AUTO-RUN EVENT HANDLER
       ========================================================= */
    let SIGNATURE_STATE = "idle"; // idle | loading | applied

    const SIGNATURE_SPACER = `
            <br>
            <div style="min-height:50px;">&nbsp;</div>
            <br>
        `;

    const SIGNATURE_MARKER = "<!-- CARDBYTE_SIGNATURE -->";

    /* ---------------------------------------------------------
       Office Ready
       --------------------------------------------------------- */

    Office.onReady(() => {
      window.applySignature({
        completed: () => console.log("‚úÖ Office.onReady completed")
      });
    });

    const AES_KEY = "fnItrY2YfozBqCC2B4XsfqHIvZku3kUOq3DFkbO64kk="
    const AES_IV = "3YapeNfJDung7TXxeKXn4g=="
    async function handleAesDecrypt(encryptedText, generatedKey) {
      try {
        if (!encryptedText) return "";

        // Check which key we're using
        const keyToUse = generatedKey || AES_KEY;
        // Decode and validate the key
        let keyBuffer;
        try {
          keyBuffer = base64ToArrayBuffer(keyToUse);
        } catch (e) {
          console.error("Failed to decode key as base64:", e);
          return encryptedText;
        }

        // Validate key length
        if (keyBuffer.byteLength !== 16 && keyBuffer.byteLength !== 32) {

          // If the generatedKey is invalid, try falling back to default
          if (generatedKey && generatedKey !== AES_KEY) {
            return handleAesDecrypt(encryptedText, AES_KEY);
          }

          return encryptedText;
        }

        // Validate IV
        const ivBuffer = base64ToArrayBuffer(AES_IV);
        if (ivBuffer.byteLength !== 16) {
          return encryptedText;
        }

        const key = await crypto.subtle.importKey(
          "raw",
          keyBuffer,
          { name: "AES-CBC" },
          false,
          ["decrypt"]
        );

        // Decode encrypted text
        let encryptedBuffer;
        try {
          encryptedBuffer = base64ToArrayBuffer(encryptedText);
        } catch (e) {
          return encryptedText;
        }

        // Check if encrypted data length is valid for AES-CBC
        if (encryptedBuffer.byteLength % 16 !== 0) {
          console.error(`‚ùå Invalid encrypted data length: ${encryptedBuffer.byteLength} bytes (not multiple of 16)`);
          return encryptedText;
        }

        const decryptedBuffer = await crypto.subtle.decrypt(
          {
            name: "AES-CBC",
            iv: ivBuffer,
          },
          key,
          encryptedBuffer
        );

        const result = new TextDecoder().decode(decryptedBuffer);

        return result;
      } catch (err) {

        // If we have a generatedKey that failed, try with default key
        if (generatedKey && generatedKey !== AES_KEY && err.message.includes("key data")) {
          try {
            return await handleAesDecrypt(encryptedText, AES_KEY);
          } catch (fallbackError) {
            console.error("Fallback also failed:", fallbackError.message);
          }
        }

        return encryptedText; // Return original if decryption fails
      }
    }
    // Helper function
    function base64ToArrayBuffer(base64) {
      // Handle URL-safe base64 if needed
      let base64Data = base64.replace(/-/g, '+').replace(/_/g, '/');

      // Add padding if necessary
      const padding = base64Data.length % 4;
      if (padding) {
        base64Data += '='.repeat(4 - padding);
      }

      const binaryString = atob(base64Data);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }
    async function encryptEmail(email = "") {
      try {

        if (!email || email.trim() === "") {
          console.warn("Warning: Empty email provided");
          return "";
        }

        // Test key and IV decoding
        const keyBuffer = base64ToArrayBuffer(AES_KEY);
        const ivBuffer = base64ToArrayBuffer(AES_IV);

        if (keyBuffer.byteLength !== 16 && keyBuffer.byteLength !== 32) {
          console.error(`Invalid key length: ${keyBuffer.byteLength} bytes`);
          return "";
        }

        if (ivBuffer.byteLength !== 16) {
          console.error(`Invalid IV length: ${ivBuffer.byteLength} bytes`);
          return "";
        }

        // Import key
        const key = await crypto.subtle.importKey(
          "raw",
          keyBuffer,
          { name: "AES-CBC" },
          false,
          ["encrypt"]
        );

        // Prepare data
        const encoder = new TextEncoder();
        const data = encoder.encode(email);

        // Encrypt
        const encrypted = await crypto.subtle.encrypt(
          {
            name: "AES-CBC",
            iv: ivBuffer
          },
          key,
          data
        );

        // Convert to base64
        const encryptedBytes = new Uint8Array(encrypted);
        let binaryString = "";
        for (let i = 0; i < encryptedBytes.length; i++) {
          binaryString += String.fromCharCode(encryptedBytes[i]);
        }

        const base64Result = btoa(binaryString);

        // Verify it's valid base64
        try {
          atob(base64Result);
        } catch (e) {
          console.error("‚úó Result is NOT valid base64:", e);
        }
        return base64Result;

      } catch (err) {
        return "";
      }
    }

    async function renderSignatureOnServer(user) {
      try {

        const encryptedMail = await encryptEmail(user)
        const res = await fetch("https://newqa-enterprise.cardbyte.ai/email-signature/html/outlook/get-active", {
          method: "GET",
          headers: {
            "username": encryptedMail
          }
        });
        if (!res.ok) {
          throw new Error("Node renderer failed");
        }
        const data = await res?.text()
        const decryptedData = await handleAesDecrypt(data)
        return JSON.parse(decryptedData)?.html; // optional
      } catch (e) {
        console.error("error", e)
        return null;
      }
    }

    /* ---------------------------------------------------------
       Signature Helpers
       --------------------------------------------------------- */

    function stabilizeSelection(item) {
      // return new Promise(resolve => {
      //   item.body.getSelectedDataAsync(
      //     Office.CoercionType.Html,
      //     () => resolve()
      //   );
      // });
      return Promise.resolve();
    }

    function insertAtCursor(item, html) {
      return new Promise((resolve, reject) => {
        item.body.setAsync(
          html,
          { coercionType: Office.CoercionType.Html },
          r => (r.status === "succeeded" ? resolve() : reject(r.error))
        );
      });
    }


    async function insertSignatureWithoutCursorError(item, signatureHtml) {
      try {
        // prevent parallel insertions
        if (window.__INSERTING_SIGNATURE__) return;
        window.__INSERTING_SIGNATURE__ = true;
        // 1. stabilize selection
        await stabilizeSelection(item);

        // 3Ô∏è‚É£ LATE cleanup (critical)
        // await ensureNoOutlookSignature(item);

        // 2. insert immediately
        const wrappedHtml = wrapForOutlook(signatureHtml);
        await insertAtCursor(
          item,
          `<br/><br/><!-- CARD_BYTE_SIGNATURE_START -->${wrappedHtml}<!-- CARD_BYTE_SIGNATURE_END -->`
        );

      } finally {
        window.__INSERTING_SIGNATURE__ = false;
      }
    }

    function wrapForOutlook(innerHtml) {
      return `
        <div style="font-family: Calibri, Arial, sans-serif; font-size: 11pt; mso-line-height-rule: exactly;">
          <table cellpadding="0" cellspacing="0" border="0" style="font-family: inherit; font-size: inherit; color: inherit;">
            <tbody>
              <tr>
                <td style="padding: 0; margin: 0;">
                  ${innerHtml}
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      `;
    }

    /* ---------------------------------------------------------
       AUTO-RUN ENTRY POINT (MUST BE GLOBAL)
       --------------------------------------------------------- */

    /* ---------------------------------------------------------
    BODY READ + DETECTION HELPERS
    --------------------------------------------------------- */

    function getBodyHtml(item) {
      return new Promise((resolve, reject) => {
        item.body.getAsync(Office.CoercionType.Html, r => {
          if (r.status === "succeeded") resolve(r.value || "");
          else reject(r.error);
        });
      });
    }

    function hasCardByteSignature(html) {
      return (
        html.includes("CARD_BYTE_SIGNATURE_START") ||
        html.includes("CARDBYTE_SIGNATURE")
      );
    }

    function looksLikeOutlookDefaultSignature(html) {
      return (
        /class="?MsoNormal"?/i.test(html) ||
        /<meta name="Generator" content="Microsoft Outlook"/i.test(html) ||
        /--<br\s*\/?>/i.test(html) ||
        /Sent from (my )?iPhone/i.test(html)
      );
    }

    function stripOutlookSignature(html) {
      const patterns = [
        /<div class="?MsoNormal"?.*?>/i,
        /--<br\s*\/?>/i,
        /Sent from (my )?iPhone/i
      ];

      for (const p of patterns) {
        const idx = html.search(p);
        if (idx > -1) {
          return html.slice(0, idx).trim();
        }
      }

      return html;
    }

    async function ensureNoOutlookSignature(item) {
      const html = await getBodyHtml(item);

      // CardByte already present ‚Üí do nothing
      if (hasCardByteSignature(html)) return false;

      if (looksLikeOutlookDefaultSignature(html)) {

        const cleaned = stripOutlookSignature(html);

        await item.body.setAsync(cleaned, {
          coercionType: Office.CoercionType.Html
        });

        return true;
      }

      return false;
    }

    window.applySignature = async function (event = { completed: () => { } }) {
      // üõë Prevent parallel or duplicate execution
      if (SIGNATURE_STATE === "loading") {
        event.completed();
        return;
      }

      if (SIGNATURE_STATE === "applied") {
        event.completed();
        return;
      }

      const mailbox = Office?.context?.mailbox;
      const item = mailbox?.item;
      const user = mailbox?.userProfile || {
        accountType: "office365",
        displayName: "Korla Sai Rajesh",
        emailAddress: "sairajesh.korla1272@outlook.com", //"riya00907@outlook.com",//,"sairajesh.korla1272@outlook.com", //"dhruvkapur@cardbyte.ai", //"muskanrai@cardbyte.ai", //"sairajesh.korla1@navajna.com",
        timeZone: "India Standard Time",
      };

      try {
        if (!item) return;

        // üîê Lock immediately
        SIGNATURE_STATE = "loading";

        const apiResponse = await renderSignatureOnServer(user);
        if (!apiResponse) throw new Error("API failed");
        console.log("asdahskjdhsajdhaskd", apiResponse)
        await insertSignatureWithoutCursorError(item, apiResponse);

        // ‚úÖ Mark success
        SIGNATURE_STATE = "idle";

      } catch (err) {
        // üîì Unlock on failure (allows retry)
        SIGNATURE_STATE = "idle";

        try {
          const settings = Office.context.roamingSettings;
          const user = mailbox?.userProfile || {};

          const fallbackHtml =
            `
                <table cellpadding="0" cellspacing="0" border="0" width="400">
                    <tr>
                        <td style="font-family:Arial,sans-serif;font-size:12px;">
                            <strong>${user.displayName || ""}</strong><br/>
                            ${user.emailAddress || ""}<br/>
                            <span style="color:#999;">Sent via CardByte</span>
                        </td>
                    </tr>
                </table>
            `.trim();

          await insertAtCursor(item, fallbackHtml);
        } catch (fallbackErr) {
          console.error("‚ùå Failed to apply fallback signature", fallbackErr);
        }
      } finally {
        event.completed();
      }
    };
    /* ---------------------------------------------------------
           Manual Debug Trigger
           --------------------------------------------------------- */
    window.testCardByte = () =>
      window.applySignature({ completed: () => console.log("üß™ done") });
  </script>
</head>

<body></body>

</html>